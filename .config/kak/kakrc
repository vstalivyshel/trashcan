colorscheme gruv-light
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
declare-option -hidden str glua "%val{config}/glua"

add-highlighter -override global/paren regex (\(|\)|\{|\}|\[|\]|<|>) 1:operator
add-highlighter -override global/ number-lines -relative -hlcursor -separator ' '
add-highlighter -override global/ show-matching 
set global ui_options terminal_assistant=none
set global tabstop 4
set global scrolloff 15,0
set global startup_info_version 999999999
set global autocomplete prompt

hook global -group insert-color ModeChange .*:.*:insert %{
    set-face window PrimaryCursor InsertCursor
    set-face window PrimaryCursorEol InsertCursor
}
hook global -group insert-color ModeChange .*:insert:.* %{ try %{
    unset-face window PrimaryCursor
    unset-face window PrimaryCursorEol 
} }

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

map global insert <c-w> '<a-;>h<a-;>b<a-;>"_d'
map global insert <c-h> <backspace>
map global insert <c-b> '<left>'
map global insert <c-f> '<right>'
map global insert <c-a> '<a-;>gi'
map global insert <c-e> '<a-;>gl<a-;>l'
map global insert <a-,> '<a-;><'
map global insert <a-.> '<a-;>>'
map global insert <c-d> '<a-;>;<a-;>"_d'

map global normal X 'x_'
map global normal . '<a-.>'
map global normal <a-.> '.'

map global normal '#' ':comment-line<ret>'
map global user w ":w<ret>" \
    -docstring 'Save'

map global user y '<a-|>xsel --input --clipboard<ret>'\
    -docstring 'Yank into system Clipboard'
map global user P '!xsel --output --clipboard<ret>'\
    -docstring 'Paste after a seletction from the system clipboard'
map global user p '<a-!>xsel --output --clipboard<ret>'\
    -docstring 'Paste before a seletction from the system clipboard'

evaluate-commands %sh{
    keys=( "h" "j" "k" "l"  "H" "J" "K" "L" )
    keys+=("o" "I" "O" "A" )
    keys+=("t" "T" "f" "F" "g" "G" "]" "[" )
    keys+=("b" "w" "e"  "B" "W" "E" )
    keys+=("x" "X")
    keys+=("c" "C" "d")
    keys+=("m" "M" "n" "N")
    cmd=""
    for k in "${keys[@]}"; do
        cmd+="map global insert <a-$k> '<esc>$k' ; "
	done
	printf %s "eval %{ $cmd }"
}

#------------------------------------------------------------------------------
# colors ----------------------------------------------------------------------

define-command make-color-current-file -override -command-completion %{
eval %sh{
    file="$kak_opt_filetype"
    if [ $file != "lua" ]; then
        printf %s "fail you are not in lua color file!"
    else
        "$kak_opt_glua/colors/make_color.lua" "$kak_buffile" "$kak_config/colors"
    fi 
} }
map global user M ':make-color-current-file<ret>' \
    -docstring 'Generate colorscheme from current lua specs'

# ------------------------------------------------------------------------------
# splits ----------------------------------------------------------------------

declare-user-mode window-mode
map global normal <c-w> ":enter-user-mode window-mode<ret>"

define-command term-vsplit \
-docstring 'Open shell in vertical split' \
-override \
%{ tmux-terminal-horizontal $SHELL  }
map global window-mode 'V' ':term-vsplit<ret>'

define-command term-hsplit \
-docstring 'Open shell in horizontal split' \
-override \
%{ tmux-terminal-vertical $SHELL  }
map global window-mode 'S' ':term-hsplit<ret>'

define-command term-tab \
-docstring 'Open shell in tab' \
-override \
%{ tmux-terminal-window $SHELL  }
map global window-mode 'T' ':term-hsplit<ret>'


declare-option -hidden str for_splits
declare-option -hidden str split_cmd 

define-command -hidden split-it-boy -params .. %{
    set buffer for_splits "e %val{buffile} ; select %val{selection_desc} ; exec vv; %arg{@}"
    %opt{split_cmd} kak -c %val{session} -e %opt{for_splits}
}

define-command buf-vsplit \
-override \
-params .. \
%{ set buffer split_cmd "tmux-terminal-horizontal" ; split-it-boy %arg{@} }
map global window-mode v ":buf-vsplit<ret>" \
    -docstring 'Open current buffer in vertical split'

define-command buf-hsplit \
-override \
-params .. \
%{ set buffer split_cmd "tmux-terminal-vertical" ; split-it-boy %arg{@} }
map global window-mode s ":buf-hsplit<ret>" \
    -docstring 'Open current buffer in horizontal split'

define-command buf-tab \
-override \
-params .. \
%{ set buffer split_cmd "tmux-terminal-window" ; split-it-boy %arg{@} }
map global window-mode t ":buf-tab<ret>" \
    -docstring 'Open current buffer in new tab'

map global window-mode q ":q<ret>" \
	-docstring 'Close current window'

#------------------------------------------------------------------------------
# little helper----------------------------------------------------------------

def eval-selected \
-override \
%{ eval %val{selection} }
map global user ';' ':eval-selected<ret>' \
    -docstring 'Eval selected text'

def eval-selected-all \
-override \
%{ evalall %val{selection} }
map global user ':' ':eval-selected-all<ret>' \
    -docstring 'Eval selected text'

def swap-selections \
-override \
%{ try %{ exec '<a-z>a<a-)>' } }
map global normal <a-r> ':swap-selections<ret>'

def jump-to-mark \
-override \
%{ on-key %{ try %{ exec %sh{ printf "\"%sz" "$kak_key" } } } }
map global normal \' ":jump-to-mark<ret>"

def surround-selection-custom \
-override \
%{prompt  'Custom-sur-obj: ' %{ eval -save-regs 'cz' %{
    set-register c %val{text}
    exec -draft -itersel 'Z"cPz"cpz'
} } }
map global user \' ":surround-selection-custom<ret>" \
    -docstring "Surrond selections with custom token"

def surround-selection \
-override \
-params 1 \
%{ on-key %{ eval -save-regs 'oc' %{
eval %sh{
    spc=""
    [ "$1" == true ] && spc=" "
    o="$kak_key"
    c=
	case "$o" in
    	"<esc>") exit 0 ;;
        "<lt>" | "<gt>") o="<" c=">" ;;
        "(" | ")") o="(" c=")" ;;
    	"[" | "]") o="[" c="]" ;;
    	"{") c="}" ;;
    	*) c+="$o" ;;
	esac
	o="$o$spc"
	c="$spc$c"
	printf %s "set-register c %¶$c¶ ;
        	   set-register o %¶$o¶ ;"
}
exec -draft -itersel '"mZ"oP"mz"cp"mz'
} } }
map global normal <a-'> ':surround-selection false<ret>'
map global normal <a-"> ':surround-selection true<ret>'

    define-command auto-info \
-docstring 'command|onkey|normal' \
-override \
-params 1 \
%{ set buffer autoinfo %arg{@} }

define-command find-file \
-docstring 'Fuzzy search for the files'\
-override \
%{ prompt  -menu  -shell-script-candidates %{
find -type f -not -path "*/colors/*" -not -path "*/\.*/*" -not -path "*/target/*"
} 'File: '  %{ try %{ edit -existing %val{text} } } }
 map global user f ':find-file<ret>' \
    -docstring 'Search for the file'

define-command find-buffer \
-docstring 'Open an exising buffer' \
-override \
%{ prompt -menu -buffer-completion 'Buffer: ' 'buffer %val{text}' }
map global user b ':find-buffer<ret>' \
    -docstring 'Serch for the active buffers'

define-command ls \
-docstring 'List files in the current directory' \
-override \
%{ info -title "%val{buffile}" %sh{ ls -Alh } }
map global normal <c-g> ":ls<ret>"

define-command sh \
-override \
-file-completion \
-params 1.. \
%{ eval %sh{ "$@" } }

define-command close-buffers \
-override \
-buffer-completion \
-params 1.. \
%{ evaluate-commands %sh{
    cmd=
    for b; do
		cmd+="db '$b'; "
    done
    printf %s "$cmd" 
} }

define-command set-filetype \
-docstring 'Set a filetype for current buffer' \
-override \
-params 1 \
%{ set-option current filetype %arg{1} }
alias global lang set-filetype

define-command new-file \
-docstring 'Create a new file(s)'\
-override \
-params 1.. \
%{ echo %sh{ touch "$@" }; edit %arg{1} }
alias global nf new-file

#------------------------------------------------------------------------------
# langmap ---------------------------------------------------------------------

declare-option str alt_langmap 'ua'
declare-option str current_langmap 'en'

set-option global modelinefmt \
'%val{bufname} %val{cursor_line}:%val{cursor_char_column} 
{{context_info}} {{mode_info}} - %val{client}@[%val{session}] - (%opt{current_langmap})'

define-command toggle-langmap \
-override \
%{ evaluate-commands %sh{
    current="en"
    alt="$kak_opt_alt_langmap"  
    [ "$kak_opt_current_langmap" == "$current" ] && current="$alt"
    "$kak_opt_glua/langmap.py" "$kak_opt_current_langmap" "$alt"
    echo "set buffer current_langmap $current"
} }
map global insert '<c-^>' '<a-;>:toggle-langmap<ret>'
map global normal '<c-^>' '<a-;>:toggle-langmap<ret>'

#------------------------------------------------------------------------------
# Autosave
define-command enable-auto-save -override  %{ 
    hook buffer -group auto-save NormalKey 'c|(?i)(d|p|u|r)' \
    %{ eval %sh{ if [ $kak_modified == true ]; then printf %s "w"; fi  } }
hook buffer -group auto-save ModeChange '.*:.*:insert' \
    %{ eval %sh{ if [ $kak_modified == true ]; then printf %s "w"; fi  } }
hook buffer -group auto-save ModeChange '.*:insert:.*' \
    %{ eval %sh{ if [ $kak_modified == true ]; then printf %s "w"; fi  } }
}
def disable-auto-save -override %{ rmhooks buffer auto-save }

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

declare-option str runcmd 
hook -group filetype-config global WinSetOption filetype=(rust|lua|python|zig) \
 %{ evaluate-commands %sh{
    fmt_cmd=
    run_cmd=
    with_file=true
    file="$kak_buffile"
    case "$kak_opt_filetype" in
        "rust") fmt_cmd="rustfmt" run_cmd="cargo build" ;;
        "lua") fmt_cmd="stylua" run_cmd="luajit $file";;
        "python") fmt_cmd="black" run_cmd="python3 $file";;
        "zig") fmt_cmd="zig fmt" run_cmd="zig run $file";;
    esac
    if ! type "$fmt_cmd" &> /dev/null; then
        printf %s "fail No such command: $fmt_cmd"
    else
        printf %s "set window formatcmd %{$fmt_cmd} ; set window runcmd %{$run_cmd}"
    fi
 } }

#------------------------------------------------------------------------------
# glua ------------------------------------------------------------------------

define-command evalall \
-docstring 'Send a kakoune command to all existing sessions' \
-override \
-command-completion \
-params 1.. \
 %{ eval %sh{ glua evalall $@ } }

 define-command run \
 -docstring "Pipe shell output into new buffer" \
 -shell-completion \
 -params 1.. \
 %{ e -fifo %sh{ glua pipe $@ } "*pipe-output*" }

define-command compile \
-docstring 'Compile current file and pipe output into a vertical split' \
-override \
-params .. \
%{ edit -fifo %sh{ glua pipe $kak_opt_runcmd $@ } "*%opt{filetype}-compile*" }
map global user r ':compile<ret>' \
    -docstring 'Execute current file in vertical split'

define-command compile-vsplit \
-docstring 'Compile current file and pipe output into a vertical split' \
-override \
-params .. \
%{ buf-vsplit %{ compile %arg{@} } }
 map global user R ':compile-vsplit<ret>' \
    -docstring 'Execute current file in vertical split'

define-command compile-hsplit \
-docstring 'Compile current file and pipe output into a horizontal split' \
-override \
-params .. \
%{ buf-hsplit %{ compile %arg{@} } }
 map global user <a-r> ':compile-hsplit<ret>' \
    -docstring 'Execute current file in horizontal split'

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# cargo

declare-option -hidden regex cargo_error_pattern \
    "^\h*(?:error|warning|note)(?:\[[A-Z0-9]+\])?: ([^\n]*)\n *--> ([^\n]*?):(\d+)(?::(\d+))?"

define-command -override -hidden cargo-open-error -params 4 %{
evaluate-commands %{
    edit -existing "%arg{1}" "%arg{2}" "%arg{3}"
    info -anchor "%arg{2}.%arg{3}" "%arg{4}"
} }

define-command -override -hidden cargo-jump %{
evaluate-commands %{
    execute-keys "/" %opt{cargo_error_pattern} <ret>
    execute-keys <a-/> %opt{cargo_error_pattern} <ret><a-:> "<a-;>"
    cargo-open-error \
        "%reg{2}" \
        "%reg{3}" \
        "%sh{ echo ${kak_main_reg_4:-1} }" \
        "%reg{1}"
} }

add-highlighter shared/cargo group
add-highlighter shared/cargo/ regex "^(error(?:\[[A-Z0-9]+\])?:)" 1:red
add-highlighter shared/cargo/ regex "^(warning(?:\[[A-Z0-9]+\])?:)" 1:yellow
add-highlighter shared/cargo/ regex "^(note(?:\[[A-Z0-9]+\])?:)" 1:green
add-highlighter shared/cargo/ regex "^ +\|[ |]+(-+[^\n]*)$" 1:cyan
add-highlighter shared/cargo/ regex "^ +\|[ |]+(\^+[^\n]*)$" 1:red

hook -group rust-compile global BufCreate '\*rust-compile\*' %{
    add-highlighter buffer/cargo ref cargo
    map buffer normal <ret> ':cargo-jump<ret>'
}

#------------------------------------------------------------------------------
# LSP -------------------------------------------------------------------------

eval %sh{kak-lsp --kakoune -s $kak_session}
map global user l %{:enter-user-mode lsp<ret>} -docstring "LSP mode"
map global insert <tab> '<a-;>:try lsp-snippets-select-next-placeholders catch %{ execute-keys -with-hooks <lt>tab> }<ret>' -docstring 'Select next snippet placeholder'
map global object e '<a-semicolon>lsp-object Function Method<ret>' -docstring 'LSP function or method'
map global object k '<a-semicolon>lsp-object Class Interface Struct<ret>' -docstring 'LSP class interface or struct'
map global object d '<a-semicolon>lsp-diagnostic-object --include-warnings<ret>' -docstring 'LSP errors and warnings'
map global object D '<a-semicolon>lsp-diagnostic-object<ret>' -docstring 'LSP errors'

lsp-inlay-diagnostics-enable global
set global lsp_hover_anchor true
