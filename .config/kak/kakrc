colorscheme lotus
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
declare-option -hidden str glua "%val{config}/glua"

add-highlighter -override global/paren regex (\(|\)|\{|\}|\[|\]|<|>) 1:operator
add-highlighter -override global/ number-lines -relative -hlcursor -separator ' '
add-highlighter -override global/ show-matching 
set global ui_options terminal_assistant=none
set global tabstop 4
set global scrolloff 15,0
set global startup_info_version 999999999
set global autocomplete prompt
set global autoinfo 'command'


hook global -group insert-color ModeChange .*:.*:insert %{
    set-face window PrimaryCursor InsertCursor
    set-face window PrimaryCursorEol InsertCursor
}
hook global -group insert-color ModeChange .*:insert:.* %{ try %{
    unset-face window PrimaryCursor
    unset-face window PrimaryCursorEol 
} }

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

map global insert <c-w> '<a-;>h<a-;>b<a-;>"_d'
map global insert <c-h> <backspace>
map global insert <c-b> '<left>'
map global insert <c-f> '<right>'
map global insert <c-a> '<a-;>gi'
map global insert <c-e> '<a-;>gl<a-;>l'
map global insert <a-,> '<a-;><'
map global insert <a-.> '<a-;>>'
map global insert <c-d> '<a-;>;<a-;>"_d'

map global normal X 'x_'
map global normal . '<a-.>'
map global normal <a-.> '.'

map global goto n '<esc>:bn<ret>'
map global goto p '<esc>:bp<ret>'

map global normal '#' ':comment-line<ret>'
map global user w ":w<ret>" \
    -docstring 'Save'

map global user y '<a-|>xsel --input --clipboard<ret>'\
    -docstring 'Yank into system Clipboard'
map global user P '!xsel --output --clipboard<ret>'\
    -docstring 'Paste after a seletction from the system clipboard'
map global user p '<a-!>xsel --output --clipboard<ret>'\
    -docstring 'Paste before a seletction from the system clipboard'

evaluate-commands %sh{
    keys=( "h" "j" "k" "l"  "H" "J" "K" "L" )
    keys+=("o" "I" "O" "A" )
    keys+=("t" "T" "f" "F" "g" "G" "]" "[" )
    keys+=("b" "w" "e"  "B" "W" "E" )
    keys+=("x" "X")
    keys+=("c" "C" "d")
    keys+=("m" "M" "n" "N")
    cmd=""
    for k in "${keys[@]}"; do
        cmd+="map global insert <a-$k> '<esc>$k' ; "
	done
	printf %s "eval %{ $cmd }"
}

#------------------------------------------------------------------------------
# colors ----------------------------------------------------------------------

define-command make-color-current-file -override -command-completion %{
eval %sh{
    file="$kak_opt_filetype"
    if [ $file != "lua" ]; then
        printf %s "fail you are not in lua color file!"
    else
        "$kak_opt_glua/colors/make_color.lua" "$kak_buffile" "$kak_config/colors"
    fi 
} }
map global user M ':make-color-current-file<ret>' \
    -docstring 'Generate colorscheme from current lua specs'

# ------------------------------------------------------------------------------
# repl -------------------------------------------------------------------------

declare-user-mode window-mode
map global normal <c-w> ":enter-user-mode window-mode<ret>"

map global window-mode 'V' ':tmux-repl-horizontal<ret>' \
-docstring 'Open shell in vertical split'
map global window-mode 'S' ':tmux-repl-vertical<ret>' \
-docstring 'Open shell in vertical split'
map global window-mode 'T' ':tmux-repl-window<ret>' \
-docstring 'Open shell in vertical split'

define-command repl-eval-text \
-docstring "repl-eval-text [text-to-eval]: Evaluate text at the REPL\n
If no text is passed, then the selection is used" \
-override \
-params ..1 %{
    eval %sh{
        if [ $# -eq 0 ]; then
            printf "%s\n" "repl-send-text"
        else
            printf "%s %s\n" "repl-send-text %{$1}"
        fi
    }
    nop %sh{tmux send -t $kak_opt_tmux_repl_id "" C-m}
}
map global user R ':repl-eval-text<ret>'

define-command repl-send-prompt \
-override \
-params ..1 \
%{ prompt 'repl-cmd ' %{ repl-eval-text %val{text}} }
map global user r ':repl-send-prompt<ret>'


define-command repl-eval-last-command \
-override \
-docstring "repl-eval-last-command: Re-run the last executed command at the REPL" \
 %{ nop %sh{tmux send -t $kak_opt_tmux_repl_id "Up" C-m} }
 map global user <a-r> ':repl-eval-last-command<ret>'

# ------------------------------------------------------------------------------
# splits ----------------------------------------------------------------------

declare-option -hidden str for_splits
declare-option -hidden str split_cmd 

define-command -hidden split-it-boy -params .. %{
    set buffer for_splits "e %val{buffile} ; select %val{selection_desc} ; exec vv; %arg{@}"
    %opt{split_cmd} kak -c %val{session} -e %opt{for_splits}
}

define-command buf-vsplit \
-override \
-params .. \
%{ set buffer split_cmd "tmux-terminal-horizontal" ; split-it-boy %arg{@} }
map global window-mode v ":buf-vsplit<ret>" \
    -docstring 'Open current buffer in vertical split'

define-command buf-hsplit \
-override \
-params .. \
%{ set buffer split_cmd "tmux-terminal-vertical" ; split-it-boy %arg{@} }
map global window-mode s ":buf-hsplit<ret>" \
    -docstring 'Open current buffer in horizontal split'

define-command buf-tab \
-override \
-params .. \
%{ set buffer split_cmd "tmux-terminal-window" ; split-it-boy %arg{@} }
map global window-mode t ":buf-tab<ret>" \
    -docstring 'Open current buffer in new tab'

map global window-mode q ":q<ret>" \
	-docstring 'Close current window'

#------------------------------------------------------------------------------
# little helper----------------------------------------------------------------

def pdf-compile \
-override \
%{ eval %sh{
    file="$kak_buffile"
    fail() { printf %s "echo -markup {Error}$1"; exit 1; }
    [ ${file##*.} != 'tex' ] && fail 'Not in a latex document'
    ! type pdflatex > /dev/null && fail '`pdflatex` is not installed'
    printf %s "
    terminal %{ pdflatex $file }
    "
} }

def pdf-open \
-override \
-params 1 \
%{ eval %sh{
    if [ ! -f $1 ] || [ ${1##*.} != "pdf" ]; then
        printf %s "fail Not a pdf document"
        exit 1
    fi
    mupdf "$1" > /dev/null 2>&1 < /dev/null &
} }

def eval-selected \
-override \
%{ eval %val{selection} }
map global user ';' ':eval-selected<ret>' \
    -docstring 'Eval selected text'

def eval-selected-all \
-override \
%{ evalall %val{selection} }
map global user ':' ':eval-selected-all<ret>' \
    -docstring 'Eval selected text'

def swap-selections \
-override \
%{ try %{ exec '<a-z>a<a-)>' } }
map global normal <a-r> ':swap-selections<ret>'

def jump-to-mark \
-override \
    %{ on-key %{ try %{ exec %sh{ printf "\"%sz" "$kak_key" } } } }
map global normal \' ":jump-to-mark<ret>"

def surround-selection-custom \
-override \
%{prompt  'Custom-sur-obj: ' %{ eval -save-regs 'cz' %{
    set-register c %val{text}
    exec -draft -itersel 'Z"cPz"cpz'
} } }
map global user \' ":surround-selection-custom<ret>" \
    -docstring "Surrond selections with custom token"

def surround-selection \
-override \
-params 1 \
%{ on-key %{ eval -save-regs 'oc' %{
eval %sh{
    spc=""
    [ "$1" == true ] && spc=" "
    o="$kak_key"
    c="$kak_key"
	case "$o" in
    	"<esc>") exit 0 ;;
        "<lt>" | "<gt>") o="<" c=">" ;;
        "(" | ")") o="(" c=")" ;;
    	"[" | "]") o="[" c="]" ;;
    	"{") c="}" ;;
	esac
	o="$o$spc"
	c="$spc$c"
	printf %s "set-register c %¶$c¶ ;
        	   set-register o %¶$o¶ ;"
}
exec -draft -itersel '"mZ"oP"mz"cp"mz'
} } }
map global normal <a-'> ':surround-selection false<ret>'
map global normal <a-"> ':surround-selection true<ret>'

define-command find-file \
-docstring 'Fuzzy search for the files'\
-override \
%{ prompt  -menu  -shell-script-candidates %{
    find -type f -not -path "*/colors/*" -not -path "*/\.*/*" -not -path "*/target/*"
} 'File: '  %{ try %{ edit -existing %val{text} } } }
 map global user f ':find-file<ret>' \
    -docstring 'Search for the file'

define-command find-buffer \
-docstring 'Open an exising buffer' \
-override \
%{ prompt -menu -buffer-completion 'Buffer: ' 'buffer %val{text}' }
map global user b ':find-buffer<ret>' \
    -docstring 'Serch for the active buffers'

define-command ls \
-docstring 'List files in the current directory' \
-override \
%{ info -title "%val{buffile}" %sh{ ls -Alh } }
map global normal <c-l> ":ls<ret>"

define-command sh \
-override \
-file-completion \
-params 1.. \
%{ echo -debug %sh{ "$@" } }

define-command close-buffers \
-override \
-buffer-completion \
-params 1.. \
%{ evaluate-commands %sh{
cmd=
    for b; do
		cmd+="db '$b'; "
    done
    printf %s "$cmd" 
} }

define-command set-filetype \
-docstring 'Set a filetype for current buffer' \
-override \
-params 1 \
%{ set-option current filetype %arg{1} }
alias global lang set-filetype

define-command new-file \
-docstring 'Create a new file(s)'\
-override \
-params 1.. \
%{ echo %sh{ touch "$@" }; edit %arg{1} }
alias global nf new-file

#------------------------------------------------------------------------------
# langmap ---------------------------------------------------------------------

declare-option str alt_langmap 'ua'
declare-option str current_langmap 'en'

set-option global modelinefmt \
'%val{bufname} %val{cursor_line}:%val{cursor_char_column} 
{{context_info}} {{mode_info}} - %val{client}@[%val{session}] - (%opt{current_langmap})'

define-command toggle-langmap \
-override \
%{ evaluate-commands %sh{
    current="en"
    alt="$kak_opt_alt_langmap"  
    [ "$kak_opt_current_langmap" == "$current" ] && current="$alt"
    "$kak_opt_glua/langmap.py" "$kak_opt_current_langmap" "$alt"
    echo "set buffer current_langmap $current"
} }
map global insert '<c-^>' '<a-;>:toggle-langmap<ret>'
map global normal '<c-^>' '<a-;>:toggle-langmap<ret>'

#------------------------------------------------------------------------------
# Autosave
define-command enable-auto-save -override  %{ 
hook buffer -group auto-save NormalKey '.*' \
    %{ eval %sh{ if [ $kak_modified == true ]; then printf %s "w"; fi  } }
hook buffer -group auto-save InsertKey '.*' \
    %{ eval %sh{ if [ $kak_modified == true ]; then printf %s "w"; fi  } }
}
def disable-auto-save -override %{ rmhooks buffer auto-save }

#------------------------------------------------------------------------------
#fmt --------------------------------------------------------------------------

hook -group filetype-config global WinSetOption filetype=(rust|lua|python|zig) \
 %{ evaluate-commands %sh{
    fmt_cmd=
    case "$kak_opt_filetype" in
        "rust") fmt_cmd="rustfmt";;
        "lua") fmt_cmd="stylua";;
        "python") fmt_cmd="black";;
        "zig") fmt_cmd="zig fmt";;
    esac
    if ! type "$fmt_cmd" &> /dev/null; then
        printf %s "fail No such command: $fmt_cmd"
    else
        printf %s "set window formatcmd %{$fmt_cmd $kak_buffile}"
    fi
 } }

#------------------------------------------------------------------------------
# glua ------------------------------------------------------------------------

define-command evalall \
-docstring 'Send a kakoune command to all existing sessions' \
-override \
-command-completion \
-params 1.. \
 %{ eval %sh{ glua evalall "$@" } }

 define-command pipe \
 -docstring "Pipe shell output into new buffer" \
 -shell-completion \
 -params 1.. \
 %{ e -fifo %sh{ glua pipe $@ } "*pipe-output*" }

#------------------------------------------------------------------------------
# LSP -------------------------------------------------------------------------

eval %sh{kak-lsp --kakoune -s $kak_session}
map global user l %{:enter-user-mode lsp<ret>} -docstring "LSP mode"
map global insert <tab> '<a-;>:try lsp-snippets-select-next-placeholders catch %{ execute-keys -with-hooks <lt>tab> }<ret>' -docstring 'Select next snippet placeholder'
map global object e '<a-semicolon>lsp-object Function Method<ret>' -docstring 'LSP function or method'
map global object k '<a-semicolon>lsp-object Class Interface Struct<ret>' -docstring 'LSP class interface or struct'
map global object d '<a-semicolon>lsp-diagnostic-object --include-warnings<ret>' -docstring 'LSP errors and warnings'
map global object D '<a-semicolon>lsp-diagnostic-object<ret>' -docstring 'LSP errors'

lsp-inlay-diagnostics-enable global
set global lsp_hover_anchor true


#------------------------------------------------------------------------------
# https://github.com/occivink/kakoune-find/blob/master/find.kak ---------------

# search for a regex pattern among all opened buffers
# similar to grep.kak

decl str toolsclient
decl str jumpclient
decl -hidden int find_current_line 0

def -params ..1 -docstring "
find [<pattern>]: search for a pattern in all buffers
If <pattern> is not specified, the content of the main selection is used
" find %{
    try %{
        eval %sh{ [ -z "$1" ] && echo fail }
        reg / %arg{1}
    } catch %{
        exec -save-regs '' '*'
    }
    eval -draft -save-regs '"' %{
        try %{ delete-buffer *find* }
        # debug so that it's not included in the iteration
        edit -scratch -debug *find-tmp*
        eval -no-hooks -buffer * %{
            try %{
                exec '%s<ret>'
                # merge selections that are on the same line
                exec '<a-s><a-L><a-;>;'
                eval -save-regs 'c"' -itersel %{
                    reg c "%val{bufname}:%val{cursor_line}:%val{cursor_column}:"
                    # expand to full line and yank
                    exec -save-regs '' '<semicolon>xHy'
                    # paste context followed by the selection
                    # older Kakoune doesn't select pasted text so make sure we
                    # to move the cursor to the end of the pasted text after P
                    exec -buffer *find-tmp* 'geo<esc>"cPhglp'
                }
            }
        }
        exec -save-regs '' 'd%y'
        delete-buffer *find-tmp*
        edit -scratch *find*
        exec R
        set buffer find_current_line 0
        addhl buffer/ regex "%reg{/}" 0:black,yellow
        # final so that %reg{/} doesn't get highlighted in the header
        addhl buffer/ regex "^([^\n]+):(\d+):(\d+):" 1:cyan,default+F 2:green,default+F 3:green,default+F
        addhl buffer/ line '%opt{find_current_line}' default+b
        map buffer normal <ret> :find-jump<ret>
    }
    eval -try-client %opt{toolsclient} %{
        buffer *find*
    }
}


def -hidden find-apply-impl -params 4 %{
    eval -buffer %arg{1} %{
        try %{
            # go to the target line and select it (except for \n)
            exec "%arg{2}g<semicolon>xH"
            # check for noop, and abort if it's one
            reg / %arg{3}
            exec <a-K><ret>
            # replace
            reg '"' %arg{4}
            exec R
            reg s "%reg{s}o"
        } catch %{
            reg i "%reg{i}o"
        }
    }
}
def -hidden find-apply-force-impl -params 4 %{
    try %{
        find-apply-impl %arg{@}
    } catch %{
        # the buffer wasn't open: try editing it
        # if this fails there is nothing we can do
        eval -verbatim -no-hooks -draft -- edit -existing %arg{1}
        find-apply-impl %arg{@}
        eval -no-hooks -buffer %arg{1} "write; delete-buffer"
    }
}

def find-apply-changes -params ..1 -docstring "
find-apply-changes [-force]: apply changes specified in the current buffer to their respective file
If -force is specified, changes will also be applied to files that do not currently have a buffer
" %{
    eval -no-hooks -save-regs 'csif' %{
        reg s ""
        reg i ""
        reg f ""
        reg c %sh{ [ "$1" = "-force" ] && printf find-apply-force-impl || printf find-apply-impl }
        eval -save-regs '/"' -draft %{
            # select all lines that match the *find* pattern
            exec '%3s^([^\n]+?):(\d+)(?::\d+)?:([^\n]*)$<ret>'
            eval -itersel %{
                try %{
                    exec -save-regs '' <a-*>
                    %reg{c} %reg{1} %reg{2} "\A%reg{/}\z" %reg{3}
                } catch %{
                    reg f "%reg{f}o"
                }
            }
        }
        echo -markup %sh{
            printf "{Information}"
            s=${#kak_main_reg_s}
            [ $s -ne 1 ] && p=s
            printf "%i change%s applied" "$s" "$p"
            i=${#kak_main_reg_i}
            [ $i -gt 0 ] && printf ", %i ignored" "$i"
            f=${#kak_main_reg_f}
            [ $f -gt 0 ] && printf ", %i failed" "$f"
        }
    }
}

def -hidden find-jump %{
    eval %{
        try %{
            exec -save-regs '' '<semicolon>xs^([^\n]+):(\d+):(\d+):<ret>'
            set buffer find_current_line %val{cursor_line}
            eval -try-client %opt{jumpclient} -verbatim -- edit -existing %reg{1} %reg{2} %reg{3}
            try %{ focus %opt{jumpclient} }
        }
    }
}

def find-next-match -docstring 'Jump to the next find match' %{
    eval -try-client %opt{jumpclient} %{
        buffer '*find*'
        exec "%opt{find_current_line}ggl/^[^\n]+:\d+:\d+:<ret>"
        find-jump
    }
    try %{ eval -client %opt{toolsclient} %{ exec %opt{find_current_line}g } }
}

def find-previous-match -docstring 'Jump to the previous find match' %{
    eval -try-client %opt{jumpclient} %{
        buffer '*find*'
        exec "%opt{find_current_line}g<a-/>^[^\n]+:\d+:\d+:<ret>"
        find-jump
    }
    try %{ eval -client %opt{toolsclient} %{ exec %opt{find_current_line}g } }
}
